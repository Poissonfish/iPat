test = Blink.LDRemove(GD[,-1], .7, 1:ncol(GD), orientation = "col")
test = Blink.LDRemove(GD[,-1], .7, 1:(ncol(GD)-1), orientation = "col")
test
test = Blink.LDRemove(GD[,-1], .7, 1:(ncol(GD)-1), orientation = "col")
test
length(test)
dim(GD)
sig = x$GWAS$P.value < (.05/ncol(GD))
sum(sig)
GD[,sig]
sig
summary(sig)
GD[,378]
GD[,sig]
which(GD[,1]=="PHM15868.56")
which(GD[,1]=="PHM15868.56")
GD[,1]
which(names(GD)=="PHM15868.56")
GD[,3041]
GD[,sig]
sig[3041]
x$GWAS$P.value[3041]
x$GWAS$P.value[3040:3042]
x$GWAS$P.value[3040:3045]
dim(x$GWAS$P.value)
length(x$GWAS$P.value)
(.05/(ncol(GD)-1))
x$GWAS$P.value
sig = x$GWAS$P.value < (.05/(ncol(GD)-1))
length(sig)
ncol(GD)
str(x)
x$GWAS$SNP
SNPname = x$GWAS$SNP
GD[,SNPname]
GD[,SNPname]%>%dim
library(magrittr)
GD[,SNPname]%>%dim
length(SNPname)
sig = x$GWAS$P.value < (.05/length(SNPname))
length(sig)
summary(sig)
test = Blink.LDRemove(GD[,SNPname], .7, 1:length(SNPname), orientation = "col")
X=GD[,SNPname]
dim(X)
X[1:10,1:10]
1:length(SNPname)
GD[,SNPname]%>%str
test = Blink.LDRemove(GD[,SNPname], .7, 1:length(SNPname), orientation = "col")
test = Blink.LDRemove(GD[,1:10], .7, 1:length(SNPname), orientation = "col")
test = Blink.LDRemove(GD[,2:11], .7, 1:10, orientation = "col")
test
str(GD[,2:11])
test = Blink.LDRemove(GD[,SNPname], .7, 1:length(SNPname), orientation = "col")
GD_sig = GD[,sig]
GD_sig
GD_sig = GD[,SNPname[sig]]
GD_sig
test = Blink.LDRemove(GD[,SNPname], .7, 1:sum(sig), orientation = "col")
test = Blink.LDRemove(GD_sig, .7, 1:sum(sig), orientation = "col")
sig = x$GWAS$P.value < (.05/100)
GD_sig = GD[,SNPname[sig]]
test = Blink.LDRemove(GD_sig, .7, 1:sum(sig), orientation = "col")
test
sig
sumary(sig)
summary(sig)
length(SNPname)
sig = x$GWAS$P.value < (.05) #length(SNPname)
GD_sig = GD[,SNPname[sig]]
GD_sig
if(sig>1){
test = Blink.LDRemove(GD_sig, .7, 1:sum(sig), orientation = "col")
}
if(length(sig)>1){
test = Blink.LDRemove(GD_sig, .7, 1:sum(sig), orientation = "col")
}
if(length(sig)>1) test = Blink.LDRemove(GD_sig, .7, 1:sum(sig), orientation = "col")
test
if(length(sig)>1) LD_remain = Blink.LDRemove(GD_sig, .7, 1:sum(sig), orientation = "col")
GD_sig2 = GD_sig[,LD_remain]
dim(GD_sig2)
dim(GD_sig)
GD_sig2
GD_sig = GD_sig[,LD_remain]
ncol(C)
ncol(C)+3
ncol(C)==NULL
is.null(ncol(C))
x$GWAS$P.value
SNPname
sig
SNPname = data.frame(x$GWAS$SNP,x$GWAS$P.value)
SNPname
SNP_p = data.frame(x$GWAS$SNP,x$GWAS$P.value)
SNP_p
SNP_p%>%head
SNP_p = data.frame(name = x$GWAS$SNP, p = x$GWAS$P.value)
head(SNP_p)
SNP_p[order(SNP_p$p),]
SNP_p = data.frame(name = x$GWAS$SNP, p = x$GWAS$P.value)
SNP_p = SNP_p[order(SNP_p$p),]
#Select associated SNP
sig = SNP_p$p < (.05) #length(SNPname)
sig
GD_sig = GD[,SNP_p$name[sig]]
GD_sig
GD_sig = GD[,SNP_p$name[sig]]
#LD Remove
if(length(sig)>1) LD_remain = Blink.LDRemove(GD_sig, .7, 1:sum(sig), orientation = "col")
GD_sig = GD_sig[,LD_remain]
nrow(Y)
ncol(c(1,2,3,4))
ncol(GD_sig)
nrow(Y)
ncol(GD_sig) -nrow(Y)
1:redundant
redundant = ncol(GD_sig) - nrow(Y)
1:redundant
redundant = -redundant
1:redundant
GD_sig[,1:redundant]
GD_sig[,1:redundant]%>%str
GD_sig[,1:redundant]%>%summary
GD_sig[,1:redundant]%>%dim
GD_sig[,!1:redundant]%>%dim
col(GD_sig)-redundant
col(GD_sig)
ncol(GD_sig)-redundant
dim(GD_sig'')
dim(GD_sig)
ncol(C)
GD_sig = GD_sig[,LD_remain]
#Check number
if(!is.null(ncol(GD_sig))){ # prevent GD_sig has only one column
if(nrow(Y)<ncol(GD_sig) && is.null(ncol(C))){
redundant = ncol(GD_sig) - nrow(Y)
GD_sig = GD_sig[,1:(ncol(GD_sig)-redundant)]
}else if(nrow(Y)<(ncol(GD_sig)+ncol(C))){
redundant = ncol(GD_sig) + ncol(C) - nrow(Y)
GD_sig = GD_sig[,1:(ncol(GD_sig)-redundant)]      }
}
GD_sig%>%dim
if(length(sig)>1) LD_remain = Blink.LDRemove(GD_sig, .7, 1:sum(sig), orientation = "col")
GD_sig = GD_sig[,LD_remain]
#Check number
if(!is.null(ncol(GD_sig))){ # prevent GD_sig has only one column
if(nrow(Y)<ncol(GD_sig) && is.null(ncol(C))){
redundant = ncol(GD_sig) - nrow(Y)
GD_sig = GD_sig[,1:(ncol(GD_sig)-redundant)]
}else if(nrow(Y)<(ncol(GD_sig)+ncol(C))){
redundant = ncol(GD_sig) + ncol(C) - nrow(Y)
GD_sig = GD_sig[,1:(ncol(GD_sig)-redundant)]      }
}
GD_sig%>%dim
#Sorted by P-value
SNP_p = data.frame(name = x$GWAS$SNP, p = x$GWAS$P.value)
SNP_p = SNP_p[order(SNP_p$p),]
#Select associated SNP
sig = SNP_p$p < (.05) #length(SNPname)
GD_sig = GD[,SNP_p$name[sig]]
#LD Remove
if(length(sig)>1) LD_remain = Blink.LDRemove(GD_sig, .7, 1:sum(sig), orientation = "col")
GD_sig = GD_sig[,LD_remain]
#Check number
if(!is.null(ncol(GD_sig))){ # prevent GD_sig has only one column
if(nrow(Y)<ncol(GD_sig) && is.null(ncol(C))){
redundant = ncol(GD_sig) - nrow(Y)
GD_sig = GD_sig[,1:(ncol(GD_sig)-redundant)]
}else if(nrow(Y)<(ncol(GD_sig)+ncol(C))){
redundant = ncol(GD_sig) + ncol(C) - nrow(Y)
GD_sig = GD_sig[,1:(ncol(GD_sig)-redundant)]      }
}
GD_sig%>%dim
#Sorted by P-value
SNP_p = data.frame(name = x$GWAS$SNP, p = x$GWAS$P.value)
SNP_p = SNP_p[order(SNP_p$p),]
#Select associated SNP
sig = SNP_p$p < (.05) #length(SNPname)
GD_sig = GD[,SNP_p$name[sig]]
#LD Remove
if(length(sig)>1) LD_remain = Blink.LDRemove(GD_sig, .7, 1:sum(sig), orientation = "col")
GD_sig = GD_sig[,LD_remain]
#Check number
if(!is.null(ncol(GD_sig))){ # prevent GD_sig has only one column
if(nrow(Y)<ncol(GD_sig) && is.null(ncol(C))){
redundant = ncol(GD_sig) - nrow(Y)
GD_sig = GD_sig[,1:(ncol(GD_sig)-redundant)]
}else if(nrow(Y)<(ncol(GD_sig)+ncol(C))){
redundant = ncol(GD_sig) + ncol(C) - nrow(Y)
GD_sig = GD_sig[,1:(ncol(GD_sig)-redundant)]      }
}
GD_sig%>%dim
!is.null(ncol(C))
!is.null(ncol(C)) && nrow(Y) < (ncol(GD_sig) + ncol(C))
#Sorted by P-value
SNP_p = data.frame(name = x$GWAS$SNP, p = x$GWAS$P.value)
SNP_p = SNP_p[order(SNP_p$p),]
#Select associated SNP
sig = SNP_p$p < (.05) #length(SNPname)
GD_sig = GD[,SNP_p$name[sig]]
#LD Remove
if(length(sig)>1) LD_remain = Blink.LDRemove(GD_sig, .7, 1:sum(sig), orientation = "col")
GD_sig = GD_sig[,LD_remain]
GD_sig%>%dim
#Check number
if(!is.null(ncol(GD_sig))){ # prevent GD_sig has only one column
if(nrow(Y)<ncol(GD_sig) && is.null(ncol(C))){
redundant = ncol(GD_sig) - nrow(Y)
GD_sig = GD_sig[,1:(ncol(GD_sig)-redundant)]
}else if(!is.null(ncol(C)) && nrow(Y) < (ncol(GD_sig) + ncol(C))){
redundant = ncol(GD_sig) + ncol(C) - nrow(Y)
GD_sig = GD_sig[,1:(ncol(GD_sig)-redundant)]      }
}
GD_sig%>%dim
if(is.null(ncol(C))){CV = GD_sig}else{CV = cbind(C, GD_sig)}
pred <- GAPIT(
Y = Y[,c(1,2)],
GM = GM,
GD = GD,
PCA.total=3,
CV = CV,
group.from=10000,
group.to=10000,
group.by=10,
SNP.test=FALSE,
memo="gBLUP"
)
source("./GAPIT_Function.R")
setwd(lib)
list.of.packages <- c("bigmemory", "biganalytics", "data.table")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages, repos="http://cran.rstudio.com/")
library(bigmemory)
library(biganalytics)
library(compiler) #this library is already installed in R
library(data.table)
source("./EMMA.R")
source("./GAPIT_Function.R")
source("./FarmCPU_Function.R")
source("./Blink.LDRemove.R")
setwd(lib)
list.of.packages <- c("bigmemory", "biganalytics", "data.table","MASS", "gplots", "compiler", "scatterplot3d", "R.utils")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages, repos="http://cran.rstudio.com/")
library(bigmemory)
library(biganalytics)
library(compiler) #this library is already installed in R
library(data.table)
library(MASS) # required for ginv
library(multtest)
library(gplots)
library(scatterplot3d)
library(R.utils)
source("./EMMA.R")
source("./GAPIT_Function.R")
source("./FarmCPU_Function.R")
source("./Blink.LDRemove.R")
pred <- GAPIT(
Y = Y[,c(1,2)],
GM = GM,
GD = GD,
PCA.total=3,
CV = CV,
group.from=10000,
group.to=10000,
group.by=10,
SNP.test=FALSE,
memo="gBLUP"
)
Y[,1]
#GAPIT do prediction
if(is.null(ncol(C))){CV = cbind(Y[,1],GD_sig)}else{CV = cbind(Y[,1], C, GD_sig)}
pred <- GAPIT(
Y = Y[,c(1,2)],
GM = GM,
GD = GD,
PCA.total=3,
CV = CV,
group.from=10000,
group.to=10000,
group.by=10,
SNP.test=FALSE,
memo="gBLUP"
)
#GAPIT do prediction
if(is.null(ncol(C))){CV = cbind(Y[,1],GD_sig)}else{CV = cbind(Y[,1], C, GD_sig)}
pred <- GAPIT(
Y = Y[,c(1,2)],
GM = GM,
GD = GD,
PCA.total=3,
CV = CV,
group.from=10000,
group.to=10000,
group.by=10,
SNP.test=FALSE,
memo="gBLUP"
)
trait_names = names(Y)
trait_names
trait_names = names(Y)[,-1]
trait_names
trait_names = names(Y)[-1]
trait_names
FarmCPU
readBin
bed=readBin("/Users/Poissonfish/Dropbox/MeetingSlides/iPat/demo_data/PLINK(Binary)/simb.bed", integer(), endian = "little")
dim(bed)
bed
bed=readBin("/Users/Poissonfish/Dropbox/MeetingSlides/iPat/demo_data/PLINK(Binary)/simb.bed", integer(),)
bed=readBin("/Users/Poissonfish/Dropbox/MeetingSlides/iPat/demo_data/PLINK(Binary)/simb.bed", integer())
[1] 1
bed
bed=readBin("/Users/Poissonfish/Dropbox/MeetingSlides/iPat/demo_data/PLINK(Binary)/simb.bed",
size = 4, n= 200,integer(), endian = "little")
bed
bed=readBin("/Users/Poissonfish/Dropbox/MeetingSlides/iPat/demo_data/PLINK(Binary)/simb.bed",
n= 200,integer(), endian = "little")
bed
file = "/Users/Poissonfish/Dropbox/MeetingSlides/iPat/demo_data/PLINK(Binary)/simb.bed"
bed=readBin(file, n= 200,integer(), endian = "little")
bed
totalsize=file.info(file)$size
totalsize
file.info(file)
lines=totalsize/32
data=readBin(file,integer(),n=totalsize,size=4,endian="little")
result=data.frame(matrix(data,nrow=lines,ncol=8,byrow=TRUE))
lines
totalsize
totalsize/64
G.path = "/Users/Poissonfish/Dropbox/MeetingSlides/iPat/demo_data/Numeric/mdp_numeric.txt"
Y.path = "/Users/Poissonfish/Dropbox/MeetingSlides/iPat/demo_data/Numeric/mdp_traits.txt"
wd = "/Users/Poissonfish/Desktop/test/rr "
args=c(1,2,3,3,1,2)
list.of.packages = c("data.table","rrBLUP")
new.packages <- list.of.packages[!(list.of.packages%in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages, repos="http://cran.rstudio.com/")
library(rrBLUP)
library(data.table)
setwd(wd)
G = fread(G.path); G = as.data.frame(G)
Y = fread(Y.path); Y = as.data.frame(Y)
taxa = c()
#Remove first column if it is taxa name
if(is.character(G[,1])){
G = G[,-1]
}
if(is.character(Y[,1])){
taxa = Y[,1]
name = names(Y)[-1]
Y = Y[,-1]
}else{
name = names(Y)
taxa = 1:ncol(Y)
}
#Select Phenotype
trait = c()
for (i in 4:length(args)){
trait = c(trait, as.numeric(args[i]))
}
Y = Y[,trait]
#Genome prediction
print('rrBLUP start')
setwd(wd)
G = fread(G.path); G = as.data.frame(G)
wd
wd = "/Users/Poissonfish/Desktop/test/rr"
setwd(wd)
G = fread(G.path); G = as.data.frame(G)
Y = fread(Y.path); Y = as.data.frame(Y)
taxa = c()
#Remove first column if it is taxa name
if(is.character(G[,1])){
G = G[,-1]
}
if(is.character(Y[,1])){
taxa = Y[,1]
name = names(Y)[-1]
Y = Y[,-1]
}else{
name = names(Y)
taxa = 1:ncol(Y)
}
#Select Phenotype
trait = c()
for (i in 4:length(args)){
trait = c(trait, as.numeric(args[i]))
}
Y = Y[,trait]
head(Y)
#Genome prediction
print('rrBLUP start')
tryCatch(
{if(is.null(ncol(Y))){
ans <- mixed.solve(Y,K=A.mat(G))
write.table(data.frame(Taxa = taxa, u = ans$u),
sprintf("rrBLUP_out_%s.txt", name[trait]),
row.names = F,
quote = F,
sep = '\t')
}else{
for(i in 1:ncol(Y)){
ans <- mixed.solve(Y[,i],K=A.mat(G))
write.table(data.frame(Taxa = taxa, u = ans$u),
sprintf("rrBLUP_out_%s.txt", name[trait[i]]),
row.names = F,
quote = F,
sep = '\t')
}
}},error = function(e){
print(e)
}
)
print(warnings())
i = 1
ans <- mixed.solve(Y[,i],K=A.mat(G))
write.table(data.frame(Taxa = taxa, u = ans$u),
sprintf("rrBLUP_out_%s.txt", name[trait[i]]),
row.names = F,
quote = F,
sep = '\t')
warnings()
error("Error Message:")
Error("Error Message:")
stop("Error Message:")
stop("")
args=c(1,2,3,1,2,3,1,2,3,1,3,2)
GM.path="/Users/Poissonfish/Dropbox/MeetingSlides/iPat/demo_data/Numeric/mdp_SNP_information.txt"
GD.path="/Users/Poissonfish/Dropbox/MeetingSlides/iPat/demo_data/Numeric/mdp_numeric.txt"
Y.path="/Users/Poissonfish/Dropbox/MeetingSlides/iPat/demo_data/Numeric/mdp_traits.txt"
C.path = "NULL"
method.bin = "optimum"
maxLoop=as.numeric("2")
MAF.calculate = as.logical("TRUE")
maf.threshold=as.numeric("0.2")
wd="/Users/Poissonfish/Desktop/test/farm"
lib = "/Users/Poissonfish/Dropbox/MeetingSlides/iPat/libs/"
args=c(1,2,3,1,2,3,1,2,3,1,3)
setwd(lib)
list.of.packages <- c("bigmemory", "biganalytics", "data.table","MASS", "gplots", "compiler", "scatterplot3d", "R.utils")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages, repos="http://cran.rstudio.com/")
library(bigmemory)
library(biganalytics)
library(compiler) #this library is already installed in R
library(data.table)
library(MASS) # required for ginv
library(multtest)
library(gplots)
library(scatterplot3d)
library(R.utils)
source("./EMMA.R")
source("./GAPIT_Function.R")
source("./FarmCPU_Function.R")
source("./Blink.LDRemove.R")
setwd(wd)
if(GM.path=="NULL"){GM=NULL}else{GM=read.table(GM.path, head=TRUE)}
if(GD.path=="NULL"){GD=NULL}else{GD=read.table(GD.path, head=TRUE)}
if(C.path=="NULL"){C=NULL}else{C=read.table(C.path, head=TRUE)}
print(length(args))
Y = read.table(Y.path, head=TRUE)
head(Y)
#Select Phenotype
trait = c()
if(length(args)>10){
for (i in 11:length(args)){
trait = c(trait, as.numeric(args[i]))
}
Y = Y[,c(trait+1)]
}
trait_names = names(Y)[-1]
trait_names
length(args)
Y = read.table(Y.path, head=TRUE)
#Select Phenotype
trait = c()
length(args)>10
for (i in 11:length(args)){
trait = c(trait, as.numeric(args[i]))
}
trait
Y = Y[,c(1,trait+1)]
Y
trait_names = names(Y)[-1]
trait_names
i=1
Y[,c(1,1+i)]
x=FarmCPU(
Y = Y[,c(1,1+i)],
GM = GM,
GD = GD,
CV = C,
method.bin= method.bin,
bin.size= c(5e5,5e6,5e7), #default set of bin.size
bin.selection= seq(10,100,10), #default set of bin.selection
maxLoop = maxLoop,
MAF.calculate=MAF.calculate,
maf.threshold=maf.threshold,
memo= trait_names[i])
Q
args
source("./*Function_FarmCPU.R")
library(dplyr)
dplyr::add_op_single()
dplyr::add_op_single()?
dplyr::add_op_single()?
dplyr::?add_op_single()
?dplyr::add_op_single()
?add_op_single()
?apply
